//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using KSP;
using UnityEngine;


namespace ModuleThermalGenerator
{
	public class ModuleThermalGenerator : ModuleGenerator
	{
		[KSPField]
		double thermalOutput = 1;

		[KSPField]
		bool scaleByGeneratorEfficiency = false;

		[KSPField]
		double finalFluxScalar = 1;

		[KSPField]
		bool haltOnDeprived = false;

		private float origResourceThreshold;

		public ModuleThermalGenerator ()
		{
		}

		public void Start()
		{
			origResourceThreshold = resourceThreshold;
		}

		public new void FixedUpdate()
		{
			double scalar = 1.0;

			if (generatorIsActive && haltOnDeprived && requiresAllInputs)
			{
				generatorIsActive = isAlwaysActive;
				foreach (GeneratorResource input in this.inputList)
				{
					if (input.isDeprived)
					{
						this.generatorIsActive = false;
						break;
					}
				}
				if (thermalOutput < 0.0 && (TotalFlux () / Math.Abs(thermalOutput)) < resourceThreshold)
					this.generatorIsActive = false;
			}
			if (requiresAllInputs && (TotalFlux () / Math.Abs(thermalOutput)) < origResourceThreshold)
			{
				resourceThreshold = int.MaxValue;
			}
			else if (resourceThreshold == int.MaxValue)
				resourceThreshold = origResourceThreshold;

			if (scaleByGeneratorEfficiency)
			{
				if (thermalOutput > 0.0)
					scalar *= this.efficiency;
			}

			part.AddThermalFlux (thermalOutput * finalFluxScalar * scalar * TimeWarp.fixedDeltaTime);
			base.FixedUpdate ();
		}

		public double TotalFlux()
		{
			// Need to use previous internal flux because that field is reset to 0 every FixedUpdate
			return part.thermalConductionFlux + part.thermalConvectionFlux + part.thermalRadiationFlux + part.thermalInternalFluxPrevious;
		}
	}
}

