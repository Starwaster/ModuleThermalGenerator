//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using KSP;
using UnityEngine;


namespace ModuleThermalGenerator
{
	public class ModuleThermalGenerator : ModuleGenerator
	{
		[KSPField]
		double thermalOutput = 1;

		[KSPField]
		bool isRequired = false;

		[KSPField]
		double scaleEfficiency = 1;

		[KSPField]
		bool haltOnDeprived = false;

		public ModuleThermalGenerator ()
		{
		}

		//public void Start()
		//{
		//}

		public new void FixedUpdate()
		{
			double scalar = 1.0;

			if (this.generatorIsActive && haltOnDeprived && requiresAllInputs)
			{
				generatorIsActive = isAlwaysActive;
				foreach (GeneratorResource input in this.inputList)
				{
					if (input.isDeprived)
					{
						this.generatorIsActive = false;
						break;
					}
				}
				if (thermalOutput < 0.0 && (TotalFlux () / Math.Abs(thermalOutput)) < resourceThreshold)
					this.generatorIsActive = false;
			}

			if (isRequired)
			{
				if (thermalOutput > 0.0)
					scalar *= this.efficiency;
				if (thermalOutput < 0.0)
				{
					scalar *= TotalFlux () / Math.Abs (thermalOutput);
				}
			}

			part.AddThermalFlux (thermalOutput * scaleEfficiency * scalar * TimeWarp.fixedDeltaTime);
			base.FixedUpdate ();
		}

		public double TotalFlux()
		{
			// Need to use previous internal flux because that field is reset to 0 every FixedUpdate
			return part.thermalConductionFlux + part.thermalConvectionFlux + part.thermalRadiationFlux + part.thermalInternalFluxPrevious;
		}
	}
}

